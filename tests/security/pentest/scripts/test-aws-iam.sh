#!/bin/bash
# STOA Platform - AWS IAM Security Testing Script
# Ticket: CAB-236
#
# Tests AWS IAM configuration, permissions, and potential misconfigurations
# IMPORTANT: Only run against authorized test environments

set -e

# Configuration
OUTPUT_DIR="${OUTPUT_DIR:-./results/aws-iam}"
AWS_REGION="${AWS_REGION:-eu-west-1}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

mkdir -p "$OUTPUT_DIR"

log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }
log_finding() {
    echo -e "${RED}[FINDING]${NC} $1"
    echo "[$(date -Iseconds)] FINDING: $1" >> "$OUTPUT_DIR/findings.log"
}

# Check AWS CLI availability
check_aws_cli() {
    if ! command -v aws &> /dev/null; then
        log_error "AWS CLI is not installed"
        exit 1
    fi

    IDENTITY=$(aws sts get-caller-identity 2>/dev/null)

    if [ -z "$IDENTITY" ]; then
        log_error "Cannot authenticate to AWS"
        exit 1
    fi

    ACCOUNT=$(echo "$IDENTITY" | jq -r '.Account')
    ARN=$(echo "$IDENTITY" | jq -r '.Arn')

    log_info "AWS Account: $ACCOUNT"
    log_info "Identity: $ARN"

    echo "$IDENTITY" > "$OUTPUT_DIR/caller-identity.json"
}

# -----------------------------------------------------------------------------
# Test 1: Enumerate IAM Roles
# -----------------------------------------------------------------------------
test_enumerate_roles() {
    log_info "Enumerating IAM roles..."

    # List all roles
    aws iam list-roles --query 'Roles[*].[RoleName,Arn,CreateDate]' --output json \
        > "$OUTPUT_DIR/all-roles.json" 2>/dev/null || true

    # Find STOA-related roles
    STOA_ROLES=$(aws iam list-roles --query 'Roles[?contains(RoleName, `stoa`) || contains(RoleName, `STOA`)].[RoleName]' --output text 2>/dev/null || true)

    if [ -n "$STOA_ROLES" ]; then
        log_info "STOA-related roles found:"
        echo "$STOA_ROLES" | while read role; do
            echo "  - $role"
        done
        echo "$STOA_ROLES" > "$OUTPUT_DIR/stoa-roles.txt"
    fi

    # Find EKS-related roles
    EKS_ROLES=$(aws iam list-roles --query 'Roles[?contains(RoleName, `eks`) || contains(RoleName, `EKS`)].[RoleName]' --output text 2>/dev/null || true)

    if [ -n "$EKS_ROLES" ]; then
        log_info "EKS-related roles found:"
        echo "$EKS_ROLES" > "$OUTPUT_DIR/eks-roles.txt"
    fi
}

# -----------------------------------------------------------------------------
# Test 2: Check Role Permissions
# -----------------------------------------------------------------------------
test_role_permissions() {
    log_info "Checking role permissions..."

    ROLES_TO_CHECK=(
        "stoa-eks-node-role"
        "stoa-control-plane-api"
        "stoa-mcp-gateway"
        "stoa-backup-role"
    )

    for role in "${ROLES_TO_CHECK[@]}"; do
        if aws iam get-role --role-name "$role" &>/dev/null; then
            log_info "Checking role: $role"

            # Get attached policies
            ATTACHED=$(aws iam list-attached-role-policies --role-name "$role" \
                --query 'AttachedPolicies[*].[PolicyName,PolicyArn]' --output json 2>/dev/null)

            echo "$ATTACHED" > "$OUTPUT_DIR/role-$role-attached.json"

            # Get inline policies
            INLINE=$(aws iam list-role-policies --role-name "$role" \
                --query 'PolicyNames' --output json 2>/dev/null)

            echo "$INLINE" > "$OUTPUT_DIR/role-$role-inline.json"

            # Check for admin policies
            if echo "$ATTACHED" | grep -qi "AdministratorAccess\|PowerUser"; then
                log_finding "Role $role has admin/power user policy attached"
            fi

            # Check for wildcard policies
            for policy_arn in $(echo "$ATTACHED" | jq -r '.[].[]' | grep 'arn:aws:iam'); do
                POLICY_DOC=$(aws iam get-policy-version \
                    --policy-arn "$policy_arn" \
                    --version-id $(aws iam get-policy --policy-arn "$policy_arn" --query 'Policy.DefaultVersionId' --output text) \
                    --query 'PolicyVersion.Document' --output json 2>/dev/null || echo "{}")

                if echo "$POLICY_DOC" | grep -q '"Action": "\*"' || echo "$POLICY_DOC" | grep -q '"Resource": "\*"'; then
                    log_warn "Policy $policy_arn has wildcard permissions"
                fi
            done
        fi
    done
}

# -----------------------------------------------------------------------------
# Test 3: Check S3 Bucket Permissions
# -----------------------------------------------------------------------------
test_s3_permissions() {
    log_info "Checking S3 bucket permissions..."

    # List STOA-related buckets
    BUCKETS=$(aws s3api list-buckets --query 'Buckets[?contains(Name, `stoa`)].[Name]' --output text 2>/dev/null || true)

    if [ -n "$BUCKETS" ]; then
        echo "$BUCKETS" > "$OUTPUT_DIR/stoa-buckets.txt"

        for bucket in $BUCKETS; do
            log_info "Checking bucket: $bucket"

            # Check bucket ACL
            ACL=$(aws s3api get-bucket-acl --bucket "$bucket" 2>/dev/null || echo "{}")
            echo "$ACL" > "$OUTPUT_DIR/bucket-$bucket-acl.json"

            # Check for public access
            if echo "$ACL" | grep -q "AllUsers\|AuthenticatedUsers"; then
                log_finding "Bucket $bucket may have public access"
            fi

            # Check bucket policy
            POLICY=$(aws s3api get-bucket-policy --bucket "$bucket" --query 'Policy' --output text 2>/dev/null || echo "{}")

            if [ -n "$POLICY" ] && [ "$POLICY" != "{}" ]; then
                echo "$POLICY" > "$OUTPUT_DIR/bucket-$bucket-policy.json"

                # Check for public policy
                if echo "$POLICY" | grep -q '"Principal": "\*"'; then
                    log_finding "Bucket $bucket has public policy"
                fi
            fi

            # Check public access block
            PUBLIC_BLOCK=$(aws s3api get-public-access-block --bucket "$bucket" 2>/dev/null || echo '{"error": "not configured"}')
            echo "$PUBLIC_BLOCK" > "$OUTPUT_DIR/bucket-$bucket-public-block.json"

            if echo "$PUBLIC_BLOCK" | grep -q '"error"'; then
                log_warn "Bucket $bucket does not have public access block configured"
            fi

            # Check encryption
            ENCRYPTION=$(aws s3api get-bucket-encryption --bucket "$bucket" 2>/dev/null || echo '{"error": "not configured"}')

            if echo "$ENCRYPTION" | grep -q '"error"'; then
                log_finding "Bucket $bucket does not have default encryption"
            fi
        done
    fi
}

# -----------------------------------------------------------------------------
# Test 4: Check KMS Key Permissions
# -----------------------------------------------------------------------------
test_kms_permissions() {
    log_info "Checking KMS key permissions..."

    # List STOA-related KMS keys
    KEYS=$(aws kms list-aliases --query 'Aliases[?contains(AliasName, `stoa`)].[AliasName,TargetKeyId]' --output json 2>/dev/null || echo "[]")

    echo "$KEYS" > "$OUTPUT_DIR/stoa-kms-keys.json"

    KEY_IDS=$(echo "$KEYS" | jq -r '.[][1]' | grep -v null || true)

    for key_id in $KEY_IDS; do
        log_info "Checking KMS key: $key_id"

        # Get key policy
        POLICY=$(aws kms get-key-policy --key-id "$key_id" --policy-name default --query 'Policy' --output text 2>/dev/null || echo "{}")
        echo "$POLICY" > "$OUTPUT_DIR/kms-$key_id-policy.json"

        # Check for overly permissive policy
        if echo "$POLICY" | grep -q '"Principal": "\*"'; then
            log_finding "KMS key $key_id has wildcard principal"
        fi

        # Check key rotation
        ROTATION=$(aws kms get-key-rotation-status --key-id "$key_id" 2>/dev/null || echo '{"KeyRotationEnabled": false}')

        if echo "$ROTATION" | grep -q '"KeyRotationEnabled": false'; then
            log_warn "KMS key $key_id does not have automatic rotation enabled"
        fi
    done
}

# -----------------------------------------------------------------------------
# Test 5: Check EKS Cluster Configuration
# -----------------------------------------------------------------------------
test_eks_configuration() {
    log_info "Checking EKS cluster configuration..."

    # List EKS clusters
    CLUSTERS=$(aws eks list-clusters --query 'clusters' --output text 2>/dev/null || true)

    for cluster in $CLUSTERS; do
        log_info "Checking EKS cluster: $cluster"

        # Get cluster details
        CLUSTER_INFO=$(aws eks describe-cluster --name "$cluster" 2>/dev/null || echo "{}")
        echo "$CLUSTER_INFO" > "$OUTPUT_DIR/eks-$cluster-info.json"

        # Check endpoint access
        PUBLIC_ACCESS=$(echo "$CLUSTER_INFO" | jq -r '.cluster.resourcesVpcConfig.endpointPublicAccess')
        PRIVATE_ACCESS=$(echo "$CLUSTER_INFO" | jq -r '.cluster.resourcesVpcConfig.endpointPrivateAccess')

        if [ "$PUBLIC_ACCESS" = "true" ] && [ "$PRIVATE_ACCESS" = "false" ]; then
            log_warn "EKS cluster $cluster has only public endpoint access"
        fi

        # Check public access CIDRs
        PUBLIC_CIDRS=$(echo "$CLUSTER_INFO" | jq -r '.cluster.resourcesVpcConfig.publicAccessCidrs[]' 2>/dev/null || true)

        if echo "$PUBLIC_CIDRS" | grep -q "0.0.0.0/0"; then
            log_finding "EKS cluster $cluster allows public access from 0.0.0.0/0"
        fi

        # Check encryption
        ENCRYPTION=$(echo "$CLUSTER_INFO" | jq '.cluster.encryptionConfig' 2>/dev/null)

        if [ "$ENCRYPTION" = "null" ] || [ -z "$ENCRYPTION" ]; then
            log_warn "EKS cluster $cluster does not have encryption configured"
        fi

        # Check logging
        LOGGING=$(echo "$CLUSTER_INFO" | jq '.cluster.logging.clusterLogging[].enabled' 2>/dev/null | grep -c "true" || echo "0")

        if [ "$LOGGING" -lt 3 ]; then
            log_warn "EKS cluster $cluster may not have all logging types enabled"
        fi
    done
}

# -----------------------------------------------------------------------------
# Test 6: Check RDS Security
# -----------------------------------------------------------------------------
test_rds_security() {
    log_info "Checking RDS security..."

    # List RDS instances
    INSTANCES=$(aws rds describe-db-instances --query 'DBInstances[*].[DBInstanceIdentifier,Engine,PubliclyAccessible,StorageEncrypted]' --output json 2>/dev/null || echo "[]")

    echo "$INSTANCES" > "$OUTPUT_DIR/rds-instances.json"

    # Check for public instances
    PUBLIC=$(echo "$INSTANCES" | jq -r '.[] | select(.[2] == true) | .[0]' 2>/dev/null || true)

    if [ -n "$PUBLIC" ]; then
        log_finding "Publicly accessible RDS instances:"
        echo "$PUBLIC" | while read instance; do
            log_warn "  - $instance"
        done
    fi

    # Check for unencrypted instances
    UNENCRYPTED=$(echo "$INSTANCES" | jq -r '.[] | select(.[3] == false) | .[0]' 2>/dev/null || true)

    if [ -n "$UNENCRYPTED" ]; then
        log_finding "Unencrypted RDS instances:"
        echo "$UNENCRYPTED" | while read instance; do
            log_warn "  - $instance"
        done
    fi
}

# -----------------------------------------------------------------------------
# Test 7: Check Security Groups
# -----------------------------------------------------------------------------
test_security_groups() {
    log_info "Checking security groups..."

    # Find security groups with 0.0.0.0/0 ingress
    OPEN_SG=$(aws ec2 describe-security-groups \
        --query 'SecurityGroups[?IpPermissions[?IpRanges[?CidrIp==`0.0.0.0/0`]]].[GroupId,GroupName]' \
        --output json 2>/dev/null || echo "[]")

    echo "$OPEN_SG" > "$OUTPUT_DIR/open-security-groups.json"

    SG_COUNT=$(echo "$OPEN_SG" | jq 'length')

    if [ "$SG_COUNT" -gt 0 ]; then
        log_warn "Security groups with 0.0.0.0/0 ingress: $SG_COUNT"

        # Check for dangerous ports
        DANGEROUS_PORTS=(22 3389 3306 5432 27017 6379)

        for port in "${DANGEROUS_PORTS[@]}"; do
            OPEN_PORT=$(aws ec2 describe-security-groups \
                --query "SecurityGroups[?IpPermissions[?FromPort==\`$port\` && IpRanges[?CidrIp==\`0.0.0.0/0\`]]].[GroupId]" \
                --output text 2>/dev/null || true)

            if [ -n "$OPEN_PORT" ]; then
                log_finding "Security groups with port $port open to 0.0.0.0/0: $OPEN_PORT"
            fi
        done
    fi
}

# -----------------------------------------------------------------------------
# Test 8: Check Secrets Manager
# -----------------------------------------------------------------------------
test_secrets_manager() {
    log_info "Checking Secrets Manager..."

    # List secrets
    SECRETS=$(aws secretsmanager list-secrets --query 'SecretList[*].[Name,ARN]' --output json 2>/dev/null || echo "[]")

    echo "$SECRETS" > "$OUTPUT_DIR/secrets-manager-list.json"

    # Check for STOA secrets
    STOA_SECRETS=$(echo "$SECRETS" | jq -r '.[] | select(.[0] | contains("stoa")) | .[0]' 2>/dev/null || true)

    if [ -n "$STOA_SECRETS" ]; then
        log_info "STOA-related secrets found:"
        echo "$STOA_SECRETS" | while read secret; do
            echo "  - $secret"

            # Check rotation
            ROTATION=$(aws secretsmanager describe-secret --secret-id "$secret" --query 'RotationEnabled' --output text 2>/dev/null || echo "false")

            if [ "$ROTATION" != "True" ]; then
                log_warn "Secret $secret does not have rotation enabled"
            fi
        done
    fi
}

# -----------------------------------------------------------------------------
# Test 9: Check CloudTrail
# -----------------------------------------------------------------------------
test_cloudtrail() {
    log_info "Checking CloudTrail configuration..."

    TRAILS=$(aws cloudtrail describe-trails --query 'trailList[*].[Name,IsMultiRegionTrail,LogFileValidationEnabled]' --output json 2>/dev/null || echo "[]")

    echo "$TRAILS" > "$OUTPUT_DIR/cloudtrail-config.json"

    TRAIL_COUNT=$(echo "$TRAILS" | jq 'length')

    if [ "$TRAIL_COUNT" -eq 0 ]; then
        log_finding "No CloudTrail trails configured"
    else
        # Check for multi-region trail
        MULTI_REGION=$(echo "$TRAILS" | jq -r '.[] | select(.[1] == true) | .[0]' 2>/dev/null || true)

        if [ -z "$MULTI_REGION" ]; then
            log_warn "No multi-region CloudTrail trail found"
        fi

        # Check log validation
        NO_VALIDATION=$(echo "$TRAILS" | jq -r '.[] | select(.[2] == false) | .[0]' 2>/dev/null || true)

        if [ -n "$NO_VALIDATION" ]; then
            log_warn "Trails without log file validation: $NO_VALIDATION"
        fi
    fi
}

# -----------------------------------------------------------------------------
# Test 10: IRSA (IAM Roles for Service Accounts)
# -----------------------------------------------------------------------------
test_irsa() {
    log_info "Checking IRSA configuration..."

    # Find roles with OIDC trust
    OIDC_ROLES=$(aws iam list-roles --query 'Roles[?contains(AssumeRolePolicyDocument.Statement[].Principal.Federated, `oidc`)].[RoleName]' --output text 2>/dev/null || true)

    if [ -n "$OIDC_ROLES" ]; then
        log_info "Roles with OIDC federation (IRSA):"
        echo "$OIDC_ROLES" > "$OUTPUT_DIR/irsa-roles.txt"

        for role in $OIDC_ROLES; do
            # Get trust policy
            TRUST=$(aws iam get-role --role-name "$role" --query 'Role.AssumeRolePolicyDocument' --output json 2>/dev/null || echo "{}")
            echo "$TRUST" > "$OUTPUT_DIR/irsa-$role-trust.json"

            # Check for overly permissive trust
            if echo "$TRUST" | grep -q '"StringLike"' && echo "$TRUST" | grep -q '"\*"'; then
                log_warn "Role $role may have overly permissive IRSA trust policy"
            fi
        done
    fi
}

# -----------------------------------------------------------------------------
# Main Execution
# -----------------------------------------------------------------------------
main() {
    echo "=============================================="
    echo "STOA Platform - AWS IAM Security Testing"
    echo "=============================================="
    echo "Region: $AWS_REGION"
    echo "Output: $OUTPUT_DIR"
    echo "=============================================="

    check_aws_cli

    # Run tests
    test_enumerate_roles
    test_role_permissions
    test_s3_permissions
    test_kms_permissions
    test_eks_configuration
    test_rds_security
    test_security_groups
    test_secrets_manager
    test_cloudtrail
    test_irsa

    echo ""
    echo "=============================================="
    echo "Testing Complete"
    echo "=============================================="
    echo "Results saved to: $OUTPUT_DIR"
    echo "Check $OUTPUT_DIR/findings.log for vulnerabilities"

    # Summary
    FINDING_COUNT=$(grep -c "FINDING" "$OUTPUT_DIR/findings.log" 2>/dev/null || echo "0")
    echo ""
    echo "Total findings: $FINDING_COUNT"
}

if [ "${BASH_SOURCE[0]}" = "$0" ]; then
    main "$@"
fi
