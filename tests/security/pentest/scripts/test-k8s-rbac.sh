#!/bin/bash
# STOA Platform - Kubernetes RBAC & Security Testing Script
# Ticket: CAB-236
#
# Tests Kubernetes RBAC, Pod Security, and Container Security
# IMPORTANT: Only run against authorized test environments

set -e

# Configuration
NAMESPACE="${NAMESPACE:-stoa-system}"
OUTPUT_DIR="${OUTPUT_DIR:-./results/k8s-security}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

mkdir -p "$OUTPUT_DIR"

log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }
log_finding() {
    echo -e "${RED}[FINDING]${NC} $1"
    echo "[$(date -Iseconds)] FINDING: $1" >> "$OUTPUT_DIR/findings.log"
}

# Check kubectl availability
check_kubectl() {
    if ! command -v kubectl &> /dev/null; then
        log_error "kubectl is not installed"
        exit 1
    fi

    if ! kubectl cluster-info &> /dev/null; then
        log_error "Cannot connect to Kubernetes cluster"
        exit 1
    fi

    log_info "Connected to cluster: $(kubectl config current-context)"
}

# -----------------------------------------------------------------------------
# Test 1: Privileged Containers
# -----------------------------------------------------------------------------
test_privileged_containers() {
    log_info "Checking for privileged containers..."

    PRIVILEGED=$(kubectl get pods -A -o json | jq -r '
        .items[] |
        select(.spec.containers[].securityContext.privileged == true) |
        "\(.metadata.namespace)/\(.metadata.name)"
    ')

    if [ -n "$PRIVILEGED" ]; then
        log_finding "Privileged containers found:"
        echo "$PRIVILEGED" | while read pod; do
            log_warn "  - $pod"
            echo "$pod" >> "$OUTPUT_DIR/privileged-containers.txt"
        done
    else
        log_info "No privileged containers found"
    fi
}

# -----------------------------------------------------------------------------
# Test 2: Host Path Mounts
# -----------------------------------------------------------------------------
test_host_path_mounts() {
    log_info "Checking for host path mounts..."

    HOST_PATHS=$(kubectl get pods -A -o json | jq -r '
        .items[] |
        select(.spec.volumes[]?.hostPath != null) |
        {
            pod: "\(.metadata.namespace)/\(.metadata.name)",
            paths: [.spec.volumes[] | select(.hostPath != null) | .hostPath.path]
        } |
        "\(.pod): \(.paths | join(", "))"
    ')

    if [ -n "$HOST_PATHS" ]; then
        log_finding "Host path mounts found:"
        echo "$HOST_PATHS" | while read line; do
            log_warn "  - $line"
            echo "$line" >> "$OUTPUT_DIR/hostpath-mounts.txt"
        done
    else
        log_info "No host path mounts found"
    fi
}

# -----------------------------------------------------------------------------
# Test 3: Host Network/PID/IPC
# -----------------------------------------------------------------------------
test_host_namespaces() {
    log_info "Checking for host namespace usage..."

    # Host Network
    HOST_NET=$(kubectl get pods -A -o json | jq -r '
        .items[] |
        select(.spec.hostNetwork == true) |
        "\(.metadata.namespace)/\(.metadata.name)"
    ')

    if [ -n "$HOST_NET" ]; then
        log_finding "Pods with hostNetwork=true:"
        echo "$HOST_NET" >> "$OUTPUT_DIR/host-network.txt"
    fi

    # Host PID
    HOST_PID=$(kubectl get pods -A -o json | jq -r '
        .items[] |
        select(.spec.hostPID == true) |
        "\(.metadata.namespace)/\(.metadata.name)"
    ')

    if [ -n "$HOST_PID" ]; then
        log_finding "Pods with hostPID=true:"
        echo "$HOST_PID" >> "$OUTPUT_DIR/host-pid.txt"
    fi

    # Host IPC
    HOST_IPC=$(kubectl get pods -A -o json | jq -r '
        .items[] |
        select(.spec.hostIPC == true) |
        "\(.metadata.namespace)/\(.metadata.name)"
    ')

    if [ -n "$HOST_IPC" ]; then
        log_finding "Pods with hostIPC=true:"
        echo "$HOST_IPC" >> "$OUTPUT_DIR/host-ipc.txt"
    fi
}

# -----------------------------------------------------------------------------
# Test 4: Service Account Token Automount
# -----------------------------------------------------------------------------
test_sa_token_automount() {
    log_info "Checking service account token automount..."

    # Pods with automountServiceAccountToken not explicitly disabled
    AUTOMOUNT=$(kubectl get pods -n "$NAMESPACE" -o json | jq -r '
        .items[] |
        select(.spec.automountServiceAccountToken != false) |
        "\(.metadata.name): SA=\(.spec.serviceAccountName // "default")"
    ')

    if [ -n "$AUTOMOUNT" ]; then
        log_warn "Pods with SA token automounted (review if necessary):"
        echo "$AUTOMOUNT" | while read line; do
            echo "  - $line"
        done
        echo "$AUTOMOUNT" > "$OUTPUT_DIR/sa-automount.txt"
    fi
}

# -----------------------------------------------------------------------------
# Test 5: Service Account Permissions
# -----------------------------------------------------------------------------
test_sa_permissions() {
    log_info "Checking service account permissions in $NAMESPACE..."

    # List service accounts
    SAS=$(kubectl get serviceaccounts -n "$NAMESPACE" -o jsonpath='{.items[*].metadata.name}')

    for sa in $SAS; do
        log_info "Checking permissions for SA: $sa"

        # Get permissions
        kubectl auth can-i --list --as=system:serviceaccount:$NAMESPACE:$sa \
            2>/dev/null > "$OUTPUT_DIR/sa-$sa-permissions.txt" || true

        # Check for dangerous permissions
        DANGEROUS=$(kubectl auth can-i --list --as=system:serviceaccount:$NAMESPACE:$sa 2>/dev/null | \
            grep -E "^\*\s+\*\s+\*|create.*secrets|delete.*secrets|create.*pods/exec|create.*pods" || true)

        if [ -n "$DANGEROUS" ]; then
            log_finding "Dangerous permissions for SA $sa:"
            echo "$DANGEROUS" | while read perm; do
                log_warn "  - $perm"
            done
        fi
    done
}

# -----------------------------------------------------------------------------
# Test 6: Cluster Role Bindings
# -----------------------------------------------------------------------------
test_cluster_role_bindings() {
    log_info "Checking cluster role bindings..."

    # ClusterRoleBindings to cluster-admin
    ADMIN_BINDINGS=$(kubectl get clusterrolebindings -o json | jq -r '
        .items[] |
        select(.roleRef.name == "cluster-admin") |
        "\(.metadata.name): \([.subjects[]? | "\(.kind)/\(.name)"] | join(", "))"
    ')

    if [ -n "$ADMIN_BINDINGS" ]; then
        log_warn "cluster-admin bindings found (review if necessary):"
        echo "$ADMIN_BINDINGS" | while read line; do
            echo "  - $line"
        done
        echo "$ADMIN_BINDINGS" > "$OUTPUT_DIR/cluster-admin-bindings.txt"
    fi

    # Service accounts in our namespace with cluster roles
    NS_BINDINGS=$(kubectl get clusterrolebindings -o json | jq -r "
        .items[] |
        select(.subjects[]?.namespace == \"$NAMESPACE\") |
        \"\(.metadata.name): \(.roleRef.name)\"
    ")

    if [ -n "$NS_BINDINGS" ]; then
        log_info "ClusterRoleBindings for $NAMESPACE:"
        echo "$NS_BINDINGS" > "$OUTPUT_DIR/namespace-cluster-bindings.txt"
    fi
}

# -----------------------------------------------------------------------------
# Test 7: Secrets Exposure
# -----------------------------------------------------------------------------
test_secrets_exposure() {
    log_info "Checking secrets in $NAMESPACE..."

    # List non-default secrets
    SECRETS=$(kubectl get secrets -n "$NAMESPACE" -o json | jq -r '
        .items[] |
        select(.type != "kubernetes.io/service-account-token") |
        "\(.metadata.name) (\(.type))"
    ')

    log_info "Secrets in namespace (excluding SA tokens):"
    echo "$SECRETS" > "$OUTPUT_DIR/secrets-list.txt"

    # Check for secrets in environment variables
    SECRETS_IN_ENV=$(kubectl get pods -n "$NAMESPACE" -o json | jq -r '
        .items[] |
        .spec.containers[] |
        select(.env[]?.valueFrom.secretKeyRef != null) |
        {
            container: .name,
            secrets: [.env[] | select(.valueFrom.secretKeyRef != null) | .valueFrom.secretKeyRef.name] | unique
        } |
        "\(.container): \(.secrets | join(", "))"
    ')

    if [ -n "$SECRETS_IN_ENV" ]; then
        log_info "Secrets referenced in env vars:"
        echo "$SECRETS_IN_ENV" > "$OUTPUT_DIR/secrets-in-env.txt"
    fi
}

# -----------------------------------------------------------------------------
# Test 8: Network Policies
# -----------------------------------------------------------------------------
test_network_policies() {
    log_info "Checking network policies..."

    # Check if network policies exist
    NP_COUNT=$(kubectl get networkpolicies -A --no-headers 2>/dev/null | wc -l)

    if [ "$NP_COUNT" -eq 0 ]; then
        log_finding "No network policies found - all pod-to-pod traffic allowed"
    else
        log_info "Found $NP_COUNT network policies"
        kubectl get networkpolicies -A -o wide > "$OUTPUT_DIR/network-policies.txt"
    fi

    # Check namespace isolation
    NP_IN_NS=$(kubectl get networkpolicies -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)

    if [ "$NP_IN_NS" -eq 0 ]; then
        log_warn "No network policies in $NAMESPACE"
    else
        log_info "Found $NP_IN_NS network policies in $NAMESPACE"
    fi
}

# -----------------------------------------------------------------------------
# Test 9: Pod Security Standards
# -----------------------------------------------------------------------------
test_pod_security() {
    log_info "Checking pod security standards..."

    # Check namespace labels for PSS
    NS_LABELS=$(kubectl get namespace "$NAMESPACE" -o json | jq -r '.metadata.labels // {}')

    PSS_ENFORCE=$(echo "$NS_LABELS" | jq -r '.["pod-security.kubernetes.io/enforce"] // "not set"')
    PSS_WARN=$(echo "$NS_LABELS" | jq -r '.["pod-security.kubernetes.io/warn"] // "not set"')
    PSS_AUDIT=$(echo "$NS_LABELS" | jq -r '.["pod-security.kubernetes.io/audit"] // "not set"')

    log_info "Pod Security Standards for $NAMESPACE:"
    echo "  Enforce: $PSS_ENFORCE"
    echo "  Warn: $PSS_WARN"
    echo "  Audit: $PSS_AUDIT"

    if [ "$PSS_ENFORCE" = "not set" ]; then
        log_warn "Pod Security Standards not enforced on namespace"
    fi

    cat << EOF > "$OUTPUT_DIR/pod-security-standards.txt"
Namespace: $NAMESPACE
Enforce: $PSS_ENFORCE
Warn: $PSS_WARN
Audit: $PSS_AUDIT
EOF
}

# -----------------------------------------------------------------------------
# Test 10: Container Images
# -----------------------------------------------------------------------------
test_container_images() {
    log_info "Checking container images..."

    # Get all images in namespace
    IMAGES=$(kubectl get pods -n "$NAMESPACE" -o json | jq -r '
        .items[].spec.containers[].image
    ' | sort -u)

    echo "$IMAGES" > "$OUTPUT_DIR/container-images.txt"

    # Check for latest tag
    LATEST_TAGS=$(echo "$IMAGES" | grep -E ':latest$|:[^:]*$' || true)

    if [ -n "$LATEST_TAGS" ]; then
        log_warn "Images with 'latest' or no tag (mutable):"
        echo "$LATEST_TAGS" | while read img; do
            echo "  - $img"
        done
    fi

    # Check for non-private registry images
    PUBLIC_IMAGES=$(echo "$IMAGES" | grep -v -E '^[a-z0-9]+\.dkr\.ecr\.|^gcr\.io/|^[a-z0-9]+\.azurecr\.io' || true)

    if [ -n "$PUBLIC_IMAGES" ]; then
        log_warn "Images from public registries:"
        echo "$PUBLIC_IMAGES" | while read img; do
            echo "  - $img"
        done
    fi
}

# -----------------------------------------------------------------------------
# Test 11: Resource Limits
# -----------------------------------------------------------------------------
test_resource_limits() {
    log_info "Checking resource limits..."

    # Containers without resource limits
    NO_LIMITS=$(kubectl get pods -n "$NAMESPACE" -o json | jq -r '
        .items[] |
        .spec.containers[] |
        select(.resources.limits == null or .resources.limits.memory == null or .resources.limits.cpu == null) |
        .name
    ' | sort -u)

    if [ -n "$NO_LIMITS" ]; then
        log_warn "Containers without resource limits:"
        echo "$NO_LIMITS" | while read container; do
            echo "  - $container"
        done
        echo "$NO_LIMITS" > "$OUTPUT_DIR/no-resource-limits.txt"
    fi
}

# -----------------------------------------------------------------------------
# Test 12: RBAC for STOA Components
# -----------------------------------------------------------------------------
test_stoa_rbac() {
    log_info "Checking STOA-specific RBAC..."

    # Check control-plane-api service account
    SA_NAME="control-plane-api"

    if kubectl get serviceaccount "$SA_NAME" -n "$NAMESPACE" &>/dev/null; then
        log_info "Checking $SA_NAME permissions..."

        kubectl auth can-i --list --as=system:serviceaccount:$NAMESPACE:$SA_NAME \
            > "$OUTPUT_DIR/control-plane-api-rbac.txt" 2>/dev/null

        # Check for overly permissive rules
        WILDCARDS=$(kubectl auth can-i --list --as=system:serviceaccount:$NAMESPACE:$SA_NAME 2>/dev/null | \
            grep -E '^\*' || true)

        if [ -n "$WILDCARDS" ]; then
            log_finding "Wildcard permissions for $SA_NAME:"
            echo "$WILDCARDS"
        fi
    fi

    # Check mcp-gateway service account
    SA_NAME="mcp-gateway"

    if kubectl get serviceaccount "$SA_NAME" -n "$NAMESPACE" &>/dev/null; then
        log_info "Checking $SA_NAME permissions..."

        kubectl auth can-i --list --as=system:serviceaccount:$NAMESPACE:$SA_NAME \
            > "$OUTPUT_DIR/mcp-gateway-rbac.txt" 2>/dev/null
    fi
}

# -----------------------------------------------------------------------------
# Test 13: Cross-Namespace Communication
# -----------------------------------------------------------------------------
test_cross_namespace() {
    log_info "Testing cross-namespace communication..."

    # Try to access services in other namespaces from a test pod
    # This is a non-destructive test

    # List services in other namespaces
    OTHER_SERVICES=$(kubectl get services -A --no-headers | grep -v "$NAMESPACE" | head -5)

    if [ -n "$OTHER_SERVICES" ]; then
        log_info "Services in other namespaces (potential cross-namespace access):"
        echo "$OTHER_SERVICES" > "$OUTPUT_DIR/other-namespace-services.txt"
    fi
}

# -----------------------------------------------------------------------------
# Test 14: AWS Metadata Access
# -----------------------------------------------------------------------------
test_aws_metadata_access() {
    log_info "Testing AWS metadata endpoint access..."

    # Get a pod in the namespace
    POD=$(kubectl get pods -n "$NAMESPACE" -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)

    if [ -n "$POD" ]; then
        # Try to access AWS metadata (non-destructive)
        log_info "Testing metadata access from pod: $POD"

        METADATA_RESULT=$(kubectl exec -n "$NAMESPACE" "$POD" -- \
            curl -s --connect-timeout 2 http://169.254.169.254/latest/meta-data/ 2>/dev/null || echo "BLOCKED")

        if [ "$METADATA_RESULT" != "BLOCKED" ] && [ -n "$METADATA_RESULT" ]; then
            log_finding "AWS metadata endpoint accessible from pod $POD"
            echo "Accessible metadata paths:" > "$OUTPUT_DIR/aws-metadata-access.txt"
            echo "$METADATA_RESULT" >> "$OUTPUT_DIR/aws-metadata-access.txt"
        else
            log_info "AWS metadata endpoint not accessible (good - IMDS v2 or blocked)"
        fi
    fi
}

# -----------------------------------------------------------------------------
# Main Execution
# -----------------------------------------------------------------------------
main() {
    echo "=============================================="
    echo "STOA Platform - Kubernetes Security Testing"
    echo "=============================================="
    echo "Namespace: $NAMESPACE"
    echo "Output: $OUTPUT_DIR"
    echo "=============================================="

    check_kubectl

    # Run tests
    test_privileged_containers
    test_host_path_mounts
    test_host_namespaces
    test_sa_token_automount
    test_sa_permissions
    test_cluster_role_bindings
    test_secrets_exposure
    test_network_policies
    test_pod_security
    test_container_images
    test_resource_limits
    test_stoa_rbac
    test_cross_namespace
    test_aws_metadata_access

    echo ""
    echo "=============================================="
    echo "Testing Complete"
    echo "=============================================="
    echo "Results saved to: $OUTPUT_DIR"
    echo "Check $OUTPUT_DIR/findings.log for vulnerabilities"

    # Summary
    FINDING_COUNT=$(wc -l < "$OUTPUT_DIR/findings.log" 2>/dev/null || echo "0")
    echo ""
    echo "Total findings: $FINDING_COUNT"
}

if [ "${BASH_SOURCE[0]}" = "$0" ]; then
    main "$@"
fi
